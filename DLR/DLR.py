import geopandas as gpd
from feedinlib import era5
import pandas as pd
import psycopg2
import numpy as np
import statistics

# The DLR_Regions function generates the dataframe with the hourly DLR (8760 h) for
# each one of the 9 regions 
def DLR_Regions(Weather_info, Regions_shape):
    #load, index and sort shapefile with the 9 regions defined by NEP 2020
    regions = gpd.read_file(Regions_shape)
    regions = regions.set_index(["Region"])
    regions = regions.sort_values(by=["Region"])
    
    #Create data frame to save results(Min wind speed, max temperature and %DLR per region along 8760h in a year)
    time = pd.date_range("2011-01-01", "2011-12-31 23:00:00", freq = "H")
    #time = time.transpose()
    dlr = pd.DataFrame(0, columns= ['R1-Wind_min', 'R1-Temp_max','R1-DLR',
                                    'R2-Wind_min', 'R2-Temp_max','R2-DLR',
                                    'R3-Wind_min', 'R3-Temp_max','R3-DLR',
                                    'R4-Wind_min', 'R4-Temp_max','R4-DLR',
                                    'R5-Wind_min', 'R5-Temp_max','R5-DLR',
                                    'R6-Wind_min', 'R6-Temp_max','R6-DLR',
                                    'R7-Wind_min', 'R7-Temp_max','R7-DLR',
                                    'R8-Wind_min', 'R8-Temp_max','R8-DLR',
                                    'R9-Wind_min', 'R9-Temp_max','R9-DLR'],
                                     index = time)
    
    #Mask weather information for each region defined by NEP 2020
    for i in range(0, len(regions)):
        #region_df = pd.DataFrame(regions.loc[i]).transpose()
        #region_df.crs = regions.crs
        region_poly = regions.iloc[i, 0]
        weather_region = era5.weather_df_from_era5(
            era5_netcdf_filename = Weather_info,
            lib='windpowerlib',
            area= region_poly)
    #Calculate and save min wind speed and max temperature in a dataframe.
    #Since the dataframe generated by the function era5.weather_df_from_era5() is sorted by date,
    #it is faster to calculate the hourly results using blocks of data defined by "step", instead of
    #using a filter or a search function.
        for j in range(0, len(time)):
            step = len(weather_region)/8760
            low_limit = int(j * step)
            up_limit = int(step*(j + 1))
            dlr.iloc[j,0+i*3] = min(weather_region.iloc[low_limit:up_limit, 0])
            dlr.iloc[j,1+i*3] = max(weather_region.iloc[low_limit:up_limit, 3])-273.15
    
    #The next loop use the min wind speed and max temperature calculated previously to
    #define the hourly DLR in for each region based on the table given by NEP 2020 pag 31
    for i in range(0, len(regions)):
        for j in range(0, len(time)):
            if dlr.iloc[j,1+i*3] <= 5:
                if dlr.iloc[j,0+i*3] < 3:
                    dlr.iloc[j,2+i*3] = 1.30
                elif dlr.iloc[j,0+i*3] < 4:
                    dlr.iloc[j,2+i*3] = 1.35
                elif dlr.iloc[j,0+i*3] < 5:
                    dlr.iloc[j,2+i*3] = 1.45
                else:
                    dlr.iloc[j,2+i*3] = 1.50
            elif dlr.iloc[j,1+i*3] <= 15:
                if dlr.iloc[j,0+i*3] < 3:
                    dlr.iloc[j,2+i*3] = 1.20
                elif dlr.iloc[j,0+i*3] < 4:
                    dlr.iloc[j,2+i*3] = 1.25
                elif dlr.iloc[j,0+i*3] < 5:
                    dlr.iloc[j,2+i*3] = 1.35
                elif dlr.iloc[j,0+i*3] < 6:
                    dlr.iloc[j,2+i*3] = 1.45
                else:
                    dlr.iloc[j,2+i*3] = 1.50
            elif dlr.iloc[j,1+i*3] <= 25:
                if dlr.iloc[j,0+i*3] < 3:
                    dlr.iloc[j,2+i*3] = 1.10
                elif dlr.iloc[j,0+i*3] < 4:
                    dlr.iloc[j,2+i*3] = 1.15
                elif dlr.iloc[j,0+i*3] < 5:
                    dlr.iloc[j,2+i*3] = 1.20
                elif dlr.iloc[j,0+i*3] < 6:
                    dlr.iloc[j,2+i*3] = 1.30
                else:
                    dlr.iloc[j,2+i*3] = 1.40
            elif dlr.iloc[j,1+i*3] <= 35:
                if dlr.iloc[j,0+i*3] < 3:
                    dlr.iloc[j,2+i*3] = 1.00
                elif dlr.iloc[j,0+i*3] < 4:
                    dlr.iloc[j,2+i*3] = 1.05
                elif dlr.iloc[j,0+i*3] < 5:
                    dlr.iloc[j,2+i*3] = 1.10
                elif dlr.iloc[j,0+i*3] < 6:
                    dlr.iloc[j,2+i*3] = 1.15
                else:
                    dlr.iloc[j,2+i*3] = 1.25
            else:
                dlr.iloc[j,2+i*3] = 1.00
    
    dlr_hourly = pd.DataFrame(index = time)
    for i in range(len(regions)):
        dlr_hourly['Reg_' + str(i+1)] = dlr.iloc[:, 3*i+2] 
    dlr_hourly.to_pickle("DLR_hourly")
    return dlr_hourly

# The Lines_in_regions function generates a df with the nominal power and
# the region(s) in which each line is.
def Lines_in_regions(Regions_shape):
    regions = gpd.read_file(Regions_shape)
    regions = regions.sort_values(by=["Region"])
    
    #Connect to the data base
    con = psycopg2.connect(host = "localhost",
                           database = "local_oedb",
                           user = "student",
                           password = "")
    
    sql = "SELECT line_id, geom, s_nom FROM grid.ego_pf_hv_line"
    df = gpd.GeoDataFrame.from_postgis(sql, con, crs = "EPSG:4326")
    df = df.drop_duplicates()
    df = df.set_index("line_id")
    trans_lines_R ={}
    for i in regions.Region:
        shape_area = regions[regions["Region"] == i]
        trans_lines_R[i] = gpd.clip(df, shape_area)        
    trans_lines= df[["s_nom"]]
    trans_lines["in_regions"] = [[] for i in range(len(df))]
    for i in trans_lines_R:
        for j in trans_lines_R[i].index:
            trans_lines.loc[j][1] = trans_lines.loc[j][1].append(i)
    trans_lines.to_pickle("trans_lines")
    return trans_lines   
    
def download_weather_data():
    latitude = [46, 56]  # [latitude south, latitude north]
    longitude = [5, 16]  # [longitude west, longitude east]
    start_date, end_date = '2011-01-01', '2011-12-31'
# set variable set to download
    variable = "windpowerlib"
    target_file = 'Germany_Weather_2011.nc'
# get windpowerlib data for specified location
    ds = era5.get_era5_data_from_datespan_and_position(
        variable=variable,
        start_date=start_date, end_date=end_date, 
        latitude=latitude, longitude=longitude,
        target_file=target_file)






# Download weather data for Germany in 2011
download_weather_data()
# Provide paths for weather information and reagions shapes
era5_netcdf_filename = "Germany_Weather_2011.nc"
regions_shape_path = "Germany borders/Germany_regions.shp"

#Calculate hourly DLR per region
DLR_hourly_df = DLR_Regions(era5_netcdf_filename, regions_shape_path)

# Generate a df with lines_id, nominal capacity, and the regions
# in which each line is.
lines = Lines_in_regions(regions_shape_path)
Trans_lines_df = lines
# Generate a diccionary with hourly DLR per region using lists
DLR_hourly_df_dic = {}
for i in DLR_hourly_df.columns:
    DLR_hourly_df_dic[i] = DLR_hourly_df[i].values

DLR = []
# Assign to each transmision line the final values of DLR based on location
# and type of line (overhead or underground) 
underground = 0
more2 = 0
outborder = 0
just1 = 0
for i in Trans_lines_df.index:
#lines completely out of the Germany border have DLR = 1
    if len(Trans_lines_df.loc[i][1]) == 0: 
        DLR.append([1]*8760)
        continue
# Underground lines have DLR = 1    
    if (Trans_lines_df.loc[i][0] % 280 == 0 or 
        Trans_lines_df.loc[i][0] % 550 == 0 or 
        Trans_lines_df.loc[i][0] % 925 == 0):
        DLR.append([1]*8760)
        continue
# Lines completely in one of the regions, have the DLR of the region   
    if len(Trans_lines_df.loc[i][1]) == 1:
        region = int(Trans_lines_df.loc[i][1][0])
        DLR.append(DLR_hourly_df_dic["Reg_" + str(region)])
        continue
# For lines crossing 2 or more regions, the lowest DLR between the
# different regions per hour is assigned.
    if len(Trans_lines_df.loc[i][1]) > 1:
        reg = []
        for j in Trans_lines_df.loc[i][1]:
            reg.append("Reg_" + str(j))
        min_DLR_reg = DLR_hourly_df[reg].min(axis = 1)
        DLR.append(list(min_DLR_reg))
               
Trans_lines_df["Hourly DLR"] = DLR
Trans_lines_df.to_pickle("Trans_lines_df")
